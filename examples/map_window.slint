import { Button, VerticalBox, ComboBox, HorizontalBox } from "std-widgets.slint";

// Define a struct to hold window size
export struct Size {
    width: length,
    height: length,
}

export global MapAdapter {
    in-out property <image> map_texture;
    callback tick_map_loop();
    callback mouse_press(float, float);
    callback mouse_release(float, float);
    callback mouse_move(float, float, bool);
    callback style_changed(string);
    callback double_click_with_shift(float, float, bool);
    callback wheel_zoom(float, float, float);
    callback fly_to(string);
}

export component MapWindow inherits Window {
    // Default window size
    preferred-width: 800px;
    preferred-height: 600px;

    // Expose window size via Size-typed property
    out property<Size> window-size: { width: root.width, height: root.height };

    // Callback when the window size changes
    callback window-size-changed;

    // Invoke callback when window-size changes
    changed window-size => { window-size-changed(); }

    // Expose map image area size so backend can match framebuffer size
    out property<Size> map-size: { width: map.width, height: map.height };
    callback map-size-changed;
    changed map-size => { map-size-changed(); }

    property <[string]> style_urls: [
        "https://demotiles.maplibre.org/style.json",
        "https://tile.openstreetmap.jp/styles/osm-bright/style.json"
    ];

    Timer {
        interval: 16ms;
        running: true;
        triggered => {
            MapAdapter.tick_map_loop();
        }
    }

    VerticalBox {
        HorizontalBox {
            ComboBox {
                model: root.style_urls;
                selected(url) => {
                    MapAdapter.style_changed(url);
                }
            }
            Button {
                text: "Paris";
                clicked => {
                    MapAdapter.fly_to("paris");
                }
            }
            Button {
                text: "New York";
                clicked => {
                    MapAdapter.fly_to("new_york");
                }
            }
            Button {
                text: "Tokyo";
                clicked => {
                    MapAdapter.fly_to("tokyo");
                }
            }
        }
        map := Image {
            source: MapAdapter.map_texture;

            touch := TouchArea {
                // Keep internal dragging state to control cursor explicitly
                property <bool> dragging: false;
                // Start drag only after a small threshold to avoid accidental map moves
                property <length> drag-threshold: 4px;
                // Track last seen Shift modifier state from pointer events
                property <bool> last-shift: false;
                mouse-cursor: self.dragging ? grabbing : grab;

                // Handle press/drag via moved + internal state
                moved => {
                    // Only engage dragging after pointer moved beyond threshold from press point
                    if (!self.dragging && self.pressed) {
                        if ( (self.mouse-x - self.pressed-x >= self.drag-threshold)
                             || (self.pressed-x - self.mouse-x >= self.drag-threshold)
                             || (self.mouse-y - self.pressed-y >= self.drag-threshold)
                             || (self.pressed-y - self.mouse-y >= self.drag-threshold) ) {
                            self.dragging = true;
                            // Initialize drag at current position to avoid initial jump
                            MapAdapter.mouse_press(self.mouse-x / 1px, self.mouse-y / 1px);
                        }
                    }
                    if (self.dragging && self.pressed) {
                        MapAdapter.mouse_move(self.mouse-x / 1px, self.mouse-y / 1px, true);
                    }
                    if (self.dragging && !self.pressed) {
                        MapAdapter.mouse_release(self.mouse-x / 1px, self.mouse-y / 1px);
                        self.dragging = false;
                    }
                }

                // Track modifiers from pointer events so we can use them in double-clicked
                pointer-event(e) => {
                    self.last-shift = e.modifiers.shift;
                }

                // Double-click to zoom in (backend handles clamping)
                double-clicked => {
                    MapAdapter.double_click_with_shift(self.mouse-x / 1px,
                                                       self.mouse-y / 1px,
                                                       self.last-shift);
                }

                // Mouse-wheel / trackpad scroll to zoom
                scroll-event(event) => {
                    // Positive delta_y: zoom out; Negative: zoom in
                    MapAdapter.wheel_zoom(self.mouse-x / 1px,
                                           self.mouse-y / 1px,
                                           event.delta_y / 1px);
                    return accept;
                }
            }
        }
    }
}